=== SIC Assembler Pass 1 Documentation ===

The pass 1 assembler builds to an executable "program1" and accepts one argument, (the .sic
assembly file to be read).  The goal of the pass 1 program is to succesfully build a symbol
table of the SIC program's labels and their corosponding memory address.

--- main.c ---
The main function begins by checking the number of arguments passed to the program, and that
the .sic file can be successfully opened.  Main uses fget to read the file line by line,
removing new line characters and carriage returns, while also keeping track of the current
line number, so that the contents and number of a line can be reprinted if a error occurs.

Each line is passed through helper function parse_line() which returns 1 if the line is valid.
If parse_line returns 0 the line has an error, the file is closed, table destroyed and main
returns -1.

In order to ensure program validitiy, main also tracks
1. The current location counter in memory (ensuring that it never exceeds 2^15)
2. The number of instructions already seen (to ensure a START directive occurs before any
other valid lines)
3. The presence of an END directive at the end of the file.

After successfully reading every line with no errors, main calls helper function print_table
and destroy_table and closes the file.

--- parse_line.c ---
This helper function accomplishes the majority of the error checking for creating the symbol table.

I opted to write this function rather than use strtok because I wanted to manually manage a
secondary char pointer "p" to parse the line and use separate parsing logic depending on what
instructions or directives had previously been seen.

A for example, &p can be passed into get_token for extracting a string deliminated by whitespace,
as well as get_address and get_constant to get memory address values or hex/character
constants respectivly.  And all three helper functions will update p to point to the next non
whitespace character following the value returned from the helper function.

parse_line accepts pointers to the location counter, number of instructions seen, and flag
denoting that an END directive has been seen alrady so that parse_line can update these values
and throw errors based on them.  (such as a START directive that follows another valid line).

Character strings such as symbol and inst are dynamically allocated, and freeing their memory
is accomplished using the helper function dangle_free that also sets them to NULL.

--- Helper Functions ---
dangle_free.c -     free memory from pointer passed by reference and set pointer value to NULL
destroy_table.c -   recursivly free memory from table pointer passed by reference and set table pointer to NULL
get_address.c -     calls strol to update an address variable with a hexidecimal value read from a string.  returns 1 if successful, 0 if not
get_constant.c -    similar to get_address.c, but also includes logic for parsing character constants, allocating sizeof(char for each character seen).  function updates variable size with the size for allocation, and constant with the actual value (perhaps useful for pass 2)
get_integer.c -     almost identical to get_address.c but decimal instead of hex.
insert_symbol.c -   adds symbol to linked list symbol table.
is_directive.c -    compares token to values in array of valid directives.  returns 1 if valid, 0 if not.
is_instruction.c -  same as is_directive.c but for instructions.
print_error.c -     prints errors in a standard format, accepts the line error occured on, contents of line, and descriptive message.
print_table.c -     recursively prints contents of symbol table.
same_word.c -       my understanding is that SIC is not case sensitive so this does a non case sensative comparison of two strings, returning 1 if they are equivalent and 0 if not.
strip_newline.c -   replaces newline and carriage return characters with the null character.
symbol_exists.c -   checks symbol table for presence of symbol with the same name.
